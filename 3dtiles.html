<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cesium flb_file</title>
    <script src="./CesiumUnminified/Cesium.js"></script>
    <link href="./CesiumUnminified/Widgets/widgets.css" rel="stylesheet" />
    <!-- <script>
        var fixGltf = function (gltf) {
            if (!gltf.extensionsUsed) {
                return;
            }

            var v = gltf.extensionsUsed.indexOf('KHR_technique_webgl');
            var t = gltf.extensionsRequired.indexOf('KHR_technique_webgl');
            // 中招了。。
            if (v !== -1) {
                gltf.extensionsRequired.splice(t, 1, 'KHR_techniques_webgl');
                gltf.extensionsUsed.splice(v, 1, 'KHR_techniques_webgl');
                gltf.extensions = gltf.extensions || {};
                gltf.extensions['KHR_techniques_webgl'] = {};
                gltf.extensions['KHR_techniques_webgl'].programs = gltf.programs;
                gltf.extensions['KHR_techniques_webgl'].shaders = gltf.shaders;
                gltf.extensions['KHR_techniques_webgl'].techniques = gltf.techniques;
                var techniques = gltf.extensions['KHR_techniques_webgl'].techniques;

                gltf.materials.forEach(function (mat, index) {
                    gltf.materials[index].extensions['KHR_technique_webgl'].values = gltf.materials[index].values;
                    gltf.materials[index].extensions['KHR_techniques_webgl'] = gltf.materials[index].extensions['KHR_technique_webgl'];

                    var vtxfMaterialExtension = gltf.materials[index].extensions['KHR_techniques_webgl'];

                    for (var value in vtxfMaterialExtension.values) {
                        var us = techniques[vtxfMaterialExtension.technique].uniforms;
                        for (var key in us) {
                            if (us[key] === value) {
                                vtxfMaterialExtension.values[key] = vtxfMaterialExtension.values[value];
                                delete vtxfMaterialExtension.values[value];
                                break;
                            }
                        }
                    };
                });

                techniques.forEach(function (t) {
                    for (var attribute in t.attributes) {
                        var name = t.attributes[attribute];
                        t.attributes[attribute] = t.parameters[name];
                    };

                    for (var uniform in t.uniforms) {
                        var name = t.uniforms[uniform];
                        t.uniforms[uniform] = t.parameters[name];
                    };
                });
            }
        }

        Object.defineProperties(Cesium.Model.prototype, {
            _cachedGltf: {
                set: function (value) {
                    this._vtxf_cachedGltf = value;
                    if (this._vtxf_cachedGltf && this._vtxf_cachedGltf._gltf) {
                        fixGltf(this._vtxf_cachedGltf._gltf);
                    }
                },
                get: function () {
                    return this._vtxf_cachedGltf;
                }
            }
        });
    </script> -->
</head>

<body>
    <div id="cesiumContainer"></div>
    <script>
        var viewer = new Cesium.Viewer("cesiumContainer");

        async function addModel() {
            const tileset = await Cesium.Cesium3DTileset.fromUrl('./SampleData/models/3dtiles/tileset.json');
            viewer.scene.primitives.add(tileset);
            viewer.zoomTo(tileset);

            // 调整模型高度
            changeHeight(tileset, -420);
        }
        addModel();

        // tileset.readyPromise.then(function (tileset) {
        //高度偏差，正数为向上偏，负数为向下偏，根据真实的模型位置不断进行调整
        function changeHeight(tileset, heightOffset) {
            height = Number(heightOffset);
            if (isNaN(heightOffset)) {
                return;
            }
            //计算tileset的绑定范围
            var boundingSphere = tileset.boundingSphere;
            //计算中心点位置
            var cartographic = Cesium.Cartographic.fromCartesian(boundingSphere.center);
            //计算中心点位置坐标
            var surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0);
            //偏移后的三维坐标
            var offset = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, heightOffset);
            var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3());
            //tileset.modelMatrix转换
            tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
        }
        // });
    </script>
</body>

</html>